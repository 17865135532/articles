# FFmpeg 视频处理入门教程

[FFmpeg](https://www.ffmpeg.org/) 是视频处理的最常用开源工具，创始于2000年。

它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。

FFmpeg 本身是一个庞大的项目，包含许多组件和库文件，最常用的是它的命令行工具。本文介绍 FFmpeg 命令行如何处理视频，非常好用，比桌面的视频处理软件更简洁高效。

如果你还没安装，可以根据[官方文档](https://www.ffmpeg.org/download.html) 先完成安装。

## 一、概念

介绍 FFmpeg 用法之前，需要了解一些关于视频的基本概念。

### 1.1 容器

视频文件本身其实是一个容器（container），里面包括了视频和音频，也可能有字幕等其他内容。

常见的容器格式有以下几种。一般来说，视频文件的后缀名反映了它的容器格式。

> - MP4
> - MKV
> - WebM
> - AVI

下面的命令查看 FFmpeg 支持的容器。

```bash
$ ffmpeg -formats
```

### 1.2 编码格式

视频和音频都需要经过编码，才能保存成文件。不同的编码格式（CODEC），有不同的压缩率，会导致文件大小和清晰度的差异。

常用的视频编码格式如下。

> - H.262
> - H.264
> - H.265

上面的编码格式都是有版权的，但是可以免费使用。此外，还有几种无版权的视频编码格式。

> - VP8
> - VP9
> - AV1

常用的音频编码格式如下。

> - MP3
> - AAC

上面所有这些都是有损的编码格式，既编码后会损失一些细节，以下换来压缩后较小的文件体积。无损的编码格式压缩出来的文件体积较大，这里就不介绍了。

下面的命令可以查看 FFmpeg 支持的编码格式，视频编码和音频编码都在内。

```bash
$ ffmpeg -codecs
```

### 1.3 编码器

编码器（encoders）是实现某种编码格式的库文件。只有安装了某种格式的编码器以后，才能实现该格式视频/音频的编码和解码。

以下是一些视频编码器。

> - libx264：最流行的开源 H.264 编码器
> - NVENC：基于 NVIDIA GPU 的 H.264 编码器
> - libx265：开源的 HEVC 编码器
> - libvpx：谷歌的 VP8 和 VP9 编码器
> - libaom：AV1 编码器

以下是一些音频编码器。

> - libfdk-aac
> - aac

下面的命令可以查看 FFmpeg 已安装的编码器。

```bash
$ ffmpeg -encoders
```

## 二、FFmpeg 的使用格式

ffmpeg {1} {2} -i {3} {4} {5}, where:

1. global options
2. input file options
3. input url
4. output file options
5. output url

**The parts 2, 3, 4 and 5 can be as many as you need. It's easier to understand this argument format in action:

```bash
$ ffmpeg \
<global-options> \
<input-options> \
-i <input> \
<output-options> \
<output>
```

```bash
# WARNING: this file is around 300MB
$ wget -O bunny_1080p_60fps.mp4 http://distribution.bbb3d.renderfarming.net/video/mp4/bbb_sunflower_1080p_60fps_normal.mp4

$ ffmpeg \
-y \ # global options
-c:a libfdk_aac -c:v libx264 \ # input options
-i bunny_1080p_60fps.mp4 \ # input url
-c:v libvpx-vp9 -c:a libvorbis \ # output options
bunny_1080p_60fps_vp9.webm # output url**
```

This command takes an input file mp4 containing two streams (an audio encoded with aac CODEC and a video encoded using h264 CODEC) and convert it to webm, changing its audio and video CODECs too.

FFmpeg will adopt or guess the default values for you. For instance when you just type ffmpeg -i input.avi output.mp4 what audio/video CODEC does it use to produce the output.mp4?

```bash
$ ffmpeg -i input.avi output.mp4
```

webm、mp4 都是容器格式。

## 用法

```bash
$ ffmpeg -i input.mp4 output.avi
```

### Transcoding

转换编码格式  (e.g. H.264 using libx264)

ffmpeg -i <input> -c:v libx264 output.mp4

视频格式（transcoding）：H264(AVC) 转 H265(HEVC)

```bash
$ ffmpeg \
-i bunny_1080p_60fps.mp4 \
-c:v libx265 \
bunny_1080p_60fps_h265.mp4
```

- `-c` sets the encoder (see ffmpeg -encoders)
- `-c copy` only copies bitstream
- `-c:v` sets only video encoders
- `-c:a` sets only audio encoders
- `-an` and `-vn` would disable audio or video streams
- `-preset`：输出的视频质量，有以下几个值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。

### Transmuxing

从一种容器转到另一种容器。

容器格式（transmuxing）：mp4 转 webm

下面是不转换编码的写法。

```
$ ffmpeg -i input.mp4 -c copy output.mkv
```

转换编码。

```bash
$ ffmpeg \
-i bunny_1080p_60fps.mp4 \
-c copy \ # just saying to ffmpeg to skip encoding
bunny_1080p_60fps.webm
```

视频的码率（transrating）：producing a rendition with bit rate between 3856K and 2000K.

```
$ ffmpeg \
-i bunny_1080p_60fps.mp4 \
-minrate 964K -maxrate 3856K -bufsize 2000K \
bunny_1080p_60fps_transrating_964_3856.mp4
```

改变视频分辨率（transsizing）：converting a 1080p to a 480p resolution.

```bash
$ ffmpeg \
-i bunny_1080p_60fps.mp4 \
-vf scale=480:-1 \
bunny_1080p_60fps_transsizing_480.mp4
```

从视频里面提取音频（demuxing）：Extracting  `audio`  from  `container`:

```bash
$ ffmpeg \
-i small_bunny_1080p_30fps.mp4 \
-vn -c:a copy \
small_bunny_audio.aac
```

音频加入视频（Muxing）

```bash
$ ffmpeg \
-i small_bunny_audio.aac -i small_bunny_1080p_30fps.mp4 \ small_bunny_1080p_30fps_muxed.mp4
```

### 截图

截图：Get images from 1s video:

```bash
$ ffmpeg \
-y \
-i /files/v/bunny_1080p_30fps.mp4 \
-ss 00:01:24 -t 00:00:01 \
smallest_bunny_1080p_30fps_%3d.jpg

$ ffmpeg \
-ss 01:23:45 \
-i input \
-vframes 1 -q:v 2 \
output.jpg
```

上面代码中，`-vframes 1`指定只截取一帧，`-q:v 2`表示输出的图片质量，`2`表示较高的质量。

### 裁剪（SEEKING AND CUTTING）

Cut a video from timestamp <start> for <duration>, or until <end>:

```bash
ffmpeg -ss <start> -i <input> -t <duration> -c copy <output>
ffmpeg -ss <start> -i <input> -to <end> -c copy <output>
```

Examples:

```bash
ffmpeg -ss 00:01:50 -i <input> -t 10.5 -c copy <output>
ffmpeg -ss 2.5 -i <input> -to 10 -c copy <output>
```

## 参考链接

- [FFmpeg libav tutorial](https://github.com/leandromoreira/ffmpeg-libav-tutorial#chapter-3---transcoding)
- [Digital video introduction](https://github.com/leandromoreira/digital_video_introduction/blob/master/encoding_pratical_examples.md#split-and-merge-smoothly)
- [FFmpeg encoding and editing course](http://slhck.info/ffmpeg-encoding-course/)
- 
