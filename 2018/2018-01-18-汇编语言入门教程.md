---


---

<h1 id="汇编语言入门教程">汇编语言入门教程</h1>
<p>学习编程其实就是学高级语言，即那些为人类设计的计算机语言。</p>
<p>但是，计算机不理解高级语言，必须通过编译器转成二进制代码，才能运行。所以，高级语言的程序，并不等同于计算机实际的运行步骤。</p>
<p>为了方便控制二进制代码，人类发明了低级语言，即那些为机器设计的语言。汇编语言是最底层的低级语言，直接控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。</p>
<p>汇编语言不容易学习，就连简明扼要的介绍都很难找到。下面我尝试写一篇最好懂的汇编语言教程，解释 CPU 如何执行代码。</p>
<h2 id="一、汇编语言是什么？">一、汇编语言是什么？</h2>
<p>我们知道，CPU 只是一个负责计算的机器零件，本身不具备智能。你输入一条指令（instruction），比如加法，它就把两个数加起来，然后停下来，等待下一条指令。</p>
<p>那些指令都是二进制的，称为操作码（opcode），比如加法指令就是<code>00000011</code>。<a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html">编译器</a>的作用，就是将高级语言写好的程序，翻译成一条条操作码。</p>
<p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p>
<p><strong>汇编语言是二进制指令的文本形式</strong>，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以直接被 CPU 执行，所以它是最底层的低级语言。</p>
<h2 id="二、来历">二、来历</h2>
<p>最早的时候，其实没有汇编语言。编写程序，就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。</p>
<p>为了解决二进制指令的可读性问题，工程师先将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行，编辑起来更是一场噩梦。</p>
<p>很自然地，指令最终还是用文字表达，加法指令写成了 ADD。内存地址也不再直接引用，而是用标签表示。这样的话，就多出了一个步骤，要把这些文字的指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。</p>
<p>那么，<strong>assembler 处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。</strong></p>
<p>每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。</p>
<h2 id="三、寄存器">三、寄存器</h2>
<p>学习汇编语言，首先必须了解 CPU 处理计算的方法，最主要的是寄存器和内存模型。</p>
<p>CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。</p>
<p>问题在于 CPU 的运算速度，远远高于内存的读写速度。如果只依靠内存储存数据，就会极大地拖慢 CPU。因此 CPU 都自带一级缓存和二级缓存，优先读写自身的缓存。基本上，CPU 缓存可以看作是内存的一部分，读写速度较快。</p>
<p>但是，数据的内存地址是不固定的，CPU 每次读写都要去不同的地址，加上寻址的时间，也会拖慢速度。因此，除了缓存之外，CPU 还自带了储存最常用数据的寄存器（register）。</p>
<p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是零级缓存，虽然不太准确，但是寄存器确实是 CPU 最优先、最频繁读写数据的地方。</p>
<p>早期的 x86 CPU 只有8个寄存器，而且每个都有自己的用途。现在的寄存器已经有100多个了，已经变成通用寄存器，不指定用途了，但是早期寄存器的名字都被保存了下来。</p>
<blockquote>
<ul>
<li>EAX</li>
<li>EBX</li>
<li>ECX</li>
<li>EDX</li>
<li>EDI</li>
<li>ESI</li>
<li>EBP</li>
<li>ESP</li>
</ul>
</blockquote>
<p>每个寄存器的大小是16位，也就是可以存放4个字节的数据。</p>
<h2 id="四、内存模型">四、内存模型</h2>
<p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，如果要了解 CPU 的运行流程，除了寄存器，还必须了解内存是怎么储存数据的。</p>
<p>首先，程序运行的时候，操作系统会给它分配一段内存，用来储存程序运行中产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p>
<p>程序运行过程中，如果用户手动要求占用内存（比如使用<code>malloc</code>命令），那么系统就会从预先分配好的那段内存之中，划出一部分给用户。具体规则是从起始地址开始，按照用户要求的大小划分。举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p>
<p>这一块因为用户主动请求而划分出来的内存区域，叫做 Heap。它由起始地址开始，从小地址到大地址增长。除此之外，内存之中还存在另一块区域，叫做 Stack，跟 CPU 的关系更密切。</p>
<h2 id="五、stack">五、Stack</h2>
<p>Stack 是由于函数运行而临时占用的内存区域，请看下面的例子。</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，系统开始执行<code>main</code>函数时，会为<code>main</code>函数在 Stack 里面分配一段区域，所有<code>main</code>的本地变量（比如<code>a</code>和<code>b</code>）都保存在这个区域里面。这个为函数本地变量而暂时存在的区域，叫做帧（frame）。<code>main</code>函数执行结束后，该区域就会被回收。</p>
<p>一旦函数内部调用了其他函数，系统就会为被调用的函数再新建一个帧。</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token function">add_a_and_b</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，<code>main</code>函数内部调用了<code>add_a_and_b</code>函数，这时系统就会在 Stack 里面为<code>add_a_and_b</code>新建一个帧，用来储存该函数的内部变量。也就是说，此时一共存在<code>main</code>和<code>add_a_and_b</code>两个帧。</p>
<p>一旦<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。通过这种机制，软件就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p>
<p>Stack 的划分规则是从内存区域的结束地址，从大到小分配。比如，内存区域的结束地址是<code>0x8000</code>，第一个帧<code>main</code>假定需要占用16字节，所以就会划分到地址<code>0x7FF0</code>，第二个帧<code>add_a_and_b</code>需要64个字节，剩余空间就会划分到<code>0x7FB0</code>。</p>
<p>每次调用函数，就形成一个新的帧，在原有帧的上方，这称为 push。函数执行结束，最上层的帧被回收，这称为 pop。如果有多层调用，看上去就像把数据堆起来一样。这也就是 Stack 这个名字的由来。</p>
<h2 id="六、cpu-指令">六、CPU 指令</h2>
<p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。</p>
<p>汇编语言由一个个 CPU 指令构成。一个简单的运算，底层可能由十几个，甚至几十个指令构成。CPU 依次执行这些指令，完成整个运算。</p>
<!--stackedit_data:&#10;eyJoaXN0b3J5IjpbMzA5NDEzOTIxXX0=&#10;-->

