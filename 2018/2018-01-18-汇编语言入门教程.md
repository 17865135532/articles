---


---

<h1 id="汇编语言入门教程">汇编语言入门教程</h1>
<p>学习编程其实就是学高级语言，即那些为人类设计的计算机语言。</p>
<p>但是，计算机不理解高级语言，必须通过编译器转成二进制代码，才能运行。所以，高级语言的程序，并不等同于计算机实际的运行步骤。</p>
<p>为了方便控制二进制代码，人类发明了低级语言，即那些为机器设计的语言。汇编语言是最底层的低级语言，直接控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。</p>
<p>汇编语言不容易学习，就连简明扼要的介绍都很难找到。下面我尝试写一篇最好懂的汇编语言教程，解释 CPU 如何执行代码。</p>
<h2 id="一、汇编语言是什么？">一、汇编语言是什么？</h2>
<p>我们知道，CPU 只是一个负责计算的机器零件，本身不具备智能。你输入一条指令（instruction），比如加法，它就把两个数加起来，然后停下来，等待下一条指令。</p>
<p>那些指令都是二进制的，称为操作码（opcode），比如加法指令就是<code>00000011</code>。<a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html">编译器</a>的作用，就是将高级语言写好的程序，翻译成一条条操作码。</p>
<p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p>
<p><strong>汇编语言是二进制指令的文本形式</strong>，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以直接被 CPU 执行，所以它是最底层的低级语言。</p>
<h2 id="二、来历">二、来历</h2>
<p>最早的时候，其实没有汇编语言。编写程序，就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。</p>
<p>为了解决二进制指令的可读性问题，工程师先将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行，编辑起来更是一场噩梦。</p>
<p>很自然地，指令最终还是用文字表达，加法指令写成了 ADD。内存地址也不再直接引用，而是用标签表示。这样的话，就多出了一个步骤，要把这些文字的指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。</p>
<p>那么，<strong>assembler 处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。</strong></p>
<p>每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。</p>
<h2 id="三、寄存器">三、寄存器</h2>
<p>学习汇编语言，首先必须了解 CPU 处理计算的方法，最主要的是寄存器和内存模型。</p>
<p>CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。</p>
<p>问题在于 CPU 的运算速度，远远高于内存的读写速度。如果只依靠内存储存数据，就会极大地拖慢 CPU。因此 CPU 都自带一级缓存和二级缓存，优先读写自身的缓存。基本上，CPU 缓存可以看作是内存的一部分，读写速度较快。</p>
<p>但是，数据的内存地址是不固定的，CPU 每次读写都要去不同的地址，加上寻址的时间，也会拖慢速度。因此，除了缓存之外，CPU 还自带了储存最常用数据的寄存器（register）。</p>
<p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是零级缓存，虽然不太准确，但是寄存器确实是 CPU 最优先、最频繁读写数据的地方。</p>
<p>早期的 x86 CPU 只有8个寄存器，而且每个都有自己的用途。现在的寄存器已经有100多个了，已经变成通用寄存器，不指定用途了，但是早期寄存器的名字都被保存了下来。</p>
<blockquote>
<ul>
<li>EAX</li>
<li>EBX</li>
<li>ECX</li>
<li>EDX</li>
<li>EDI</li>
<li>ESI</li>
<li>EBP</li>
<li>ESP</li>
</ul>
</blockquote>
<p>每个寄存器的大小是16位，也就是可以存放4个字节的数据。</p>
<h2 id="四、内存模型">四、内存模型</h2>
<p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，如果要了解 CPU 的运行流程，除了寄存器，还必须了解内存是怎么储存数据的。</p>
<p>首先，程序运行的时候，操作系统会给它分配一段内存，用来储存程序运行中产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p>
<p>程序运行过程中，如果用户手动要求占用内存（比如使用<code>malloc</code>命令），那么系统就会从预先分配好的那段内存之中，划出一部分给用户。具体规则是从起始地址开始，按照用户要求的大小划分。举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p>
<p>这一块因为用户主动请求而划分出来的内存区域，叫做 Heap。它由起始地址开始，从小地址到大地址增长。除此之外，内存之中还存在另一块区域，叫做 Stack，跟 CPU 的关系更密切。</p>
<h2 id="五、stack">五、Stack</h2>
<p>Stack 是由于函数运行而临时占用的内存区域，请看下面的例子。</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，系统开始执行<code>main</code>函数时，会为<code>main</code>函数在 Stack 里面分配一段区域，所有<code>main</code>的本地变量（比如<code>a</code>和<code>b</code>）都保存在这个区域里面。这个为函数本地变量而暂时存在的区域，叫做帧（frame）。<code>main</code>函数执行结束后，该区域就会被回收。</p>
<p>一旦函数内部调用了其他函数，系统就会为被调用的函数再新建一个帧。</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token function">add_a_and_b</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，<code>main</code>函数内部调用了<code>add_a_and_b</code>函数，这时系统就会在 Stack 里面为<code>add_a_and_b</code>新建一个帧，用来储存该函数的内部变量。也就是说，此时一共存在<code>main</code>和<code>add_a_and_b</code>两个帧。</p>
<p>一旦<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。通过这种机制，软件就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p>
<p>Stack 的划分规则是从内存区域的结束地址，从大到小分配。比如，内存区域的结束地址是<code>0x8000</code>，第一个帧<code>main</code>假定需要占用16字节，所以就会划分到地址<code>0x7FF0</code>，第二个帧<code>add_a_and_b</code>需要64个字节，剩余空间就会划分到<code>0x7FB0</code>。</p>
<p>每次调用函数，就形成一个新的帧，在原有帧的上方，这称为 push。函数执行结束，最上层的帧被回收，这称为 pop。如果有多层调用，看上去就像把数据堆起来一样。这也就是 Stack 这个名字的由来。</p>
<h2 id="六、cpu-指令">六、CPU 指令</h2>
<p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序<code>example.c</code>。</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">int</span> <span class="token function">add_a_and_b</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token function">add_a_and_b</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>然后，使用 gcc 将这个程序转成汇编程序。</p>
<pre class=" language-bash"><code class="prism  language-bash">$ gcc -S example.c
</code></pre>
<p>上面的命令执行以后，会生成一个文本文件<code>example.s</code>，里面就是汇编语言的代码。你可以打开看一下，大概有几十行。一个简单的运算，底层可能由十几个，甚至几十个 CPU 操作构成。CPU 依次执行这些操作，完成整个运算。</p>
<p>生成的汇编程序，简化以后大概是下面的样子。</p>
<pre class=" language-c"><code class="prism  language-c">_add_a_and_b<span class="token punctuation">:</span>
   push   <span class="token operator">%</span>ebx
   mov    <span class="token operator">%</span>eax<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">%</span>esp<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">]</span> 
   mov    <span class="token operator">%</span>ebx<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">%</span>esp<span class="token operator">+</span><span class="token number">12</span><span class="token punctuation">]</span>
   add    <span class="token operator">%</span>eax<span class="token punctuation">,</span> <span class="token operator">%</span>ebx 
   pop    <span class="token operator">%</span>ebx 
   ret  

_main<span class="token punctuation">:</span>
   push   <span class="token number">3</span>
   push   <span class="token number">2</span>
   call   _add_a_and_b 
   add    <span class="token operator">%</span>esp<span class="token punctuation">,</span> <span class="token number">8</span>
   ret
</code></pre>
<p>可以看到，原程序里面有两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数的代码所转成的 CPU 操作流程。</p>
<p>每一行就是 CPU 执行的一次操作。它又分成两部分。</p>
<pre class=" language-c"><code class="prism  language-c">push   <span class="token operator">%</span>ebx
</code></pre>
<p>上面这一行代码，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令的运算子。一个 CPU 指令可以零到多个运算子。</p>
<p>下面会一行一行讲解这个汇编程序。你最好把这个程序在另一个窗口拷贝一份，以便对照阅读。</p>
<h2 id="七、push-指令">七、push 指令</h2>
<p>系统从<code>main</code>函数开始执行。所以，执行的第一行代码如下。</p>
<pre class=" language-c"><code class="prism  language-c">push   <span class="token number">3</span>
</code></pre>
<p><code>push</code>命令用于将运算子放入堆栈，上面的代码就是<code>3</code>放入 Stack。</p>
<p>实际的运算步骤有一点复杂。首先，<code>push</code>会将 ESP 寄存器里面的 Stack 地址减去4字节，由于 Stack 的地址是从大到小变化，这就意味着留出了32位的储存空间。然后，就是这个新的地址，存入运算子（本例是3）。</p>
<p>后面一行也是一样。</p>
<pre class=" language-c"><code class="prism  language-c">push   <span class="token number">2</span>
</code></pre>
<p><code>push</code>指令再将 Stack 地址减去 4（累计减去8），然后将2放入 Stack。</p>
<h2 id="八、call-指令">八、call 指令</h2>
<p><code>call</code>指令用来调用函数。</p>
<pre class=" language-c"><code class="prism  language-c">call   _add_a_and_b
</code></pre>
<p>上面的代码表示找到<code>_add_a_and_b</code>标签，然后去执行该函数的代码。<code>add_a_and_b</code>函数的第一行代码如下。</p>
<pre class=" language-c"><code class="prism  language-c">push   <span class="token operator">%</span>ebx
</code></pre>
<p><code>push</code>指令再将 Stack 的地址减去4（累计减去12），然后将<code>ebx</code>寄存器的值放入 Stack。这是因为后面要用到这个寄存器，先把这个值取出来，后面可以再写回去。</p>
<h2 id="九、mov-指令">九、mov 指令</h2>
<p><code>mov</code>指令用于将一个值写入某个寄存器。</p>
<pre class=" language-c"><code class="prism  language-c">mov    <span class="token operator">%</span>eax<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">%</span>esp<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">]</span> 
</code></pre>
<p>上面的代码表示，先将<code>esp</code>寄存器的地址加8，然后按照这个内存地址在 Stack 取出数据。根据前面的步骤，这时取出的是<code>add_a_and_b</code> 函数的第一个参数2，再将2写入<code>eax</code>寄存器。</p>
<pre class=" language-c"><code class="prism  language-c">mov    <span class="token operator">%</span>ebx<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">%</span>esp<span class="token operator">+</span><span class="token number">12</span><span class="token punctuation">]</span> 
</code></pre>
<p>上面的代码将<code>esp</code>寄存器的地址加12，然后按照这个内存地址在 Stack 取出数据，即是<code>add_a_and_b</code> 函数的第二个参数3，再将3写入<code>ebx</code>寄存器。</p>
<h2 id="十、add-指令">十、add 指令</h2>
<p><code>add</code>指令将两个运算子相加，并将结果写入第一个运算子。</p>
<pre class=" language-c"><code class="prism  language-c">add    <span class="token operator">%</span>eax<span class="token punctuation">,</span> <span class="token operator">%</span>ebx
</code></pre>
<p>上面的代码将<code>eax</code>寄存器的值（即2）加上<code>ebx</code>寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子<code>eax</code>寄存器。</p>
<h2 id="十一、pop-指令">十一、pop 指令</h2>
<p><code>pop</code>指令用于取出 Stack 最上层的值，并将这个值用于运算子指定的位置。然后将<code>esp</code>寄存器里面的地址加4，即回收4个字节。</p>
<pre class=" language-c"><code class="prism  language-c">pop    <span class="token operator">%</span>ebx
</code></pre>
<p>上面的代码表示，取出 Stack 最上层的4个字节的值（即<code>ebx</code>寄存器的原始值），再将这个值写回<code>ebx</code>寄存器。</p>
<h2 id="十二、ret">十二、<code>ret</code></h2>
<p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。这也意味着当前函数形成的帧会被全部回收。</p>
<pre class=" language-c"><code class="prism  language-c">ret
</code></pre>
<p>可以看到，该指令没有运算子。</p>
<p>随着<code>add_a_and_b</code>函数终止执行，系统就回到刚才<code>main</code>函数中断的地方，继续往下执行。</p>
<pre class=" language-c"><code class="prism  language-c">add    <span class="token operator">%</span>esp<span class="token punctuation">,</span> <span class="token number">8</span> 
</code></pre>
<p>上面的代码表示，将<code>esp</code>寄存器的值加上8，再写回<code>esp</code>寄存器。由于<code>esp</code>保存的是 Stack 的开始地址，前面的<code>pop</code>操作已经回收了四个字节，这里再回收8个字节，等于全部回收。</p>
<p>最后，<code>main</code>函数运行结束，<code>ret</code>命令推出程序执行。</p>
<!--stackedit_data:&#10;eyJoaXN0b3J5IjpbMzA5NDEzOTIxXX0=&#10;-->
<h2 id="参考链接">参考链接</h2>

