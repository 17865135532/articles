# Prolog 语言入门教程

Prolog 是一种与众不同的语言，不用来开发软件，专门用于解决逻辑问题。

它的名字就是“逻辑编程”（programming of Logic）的意思。只要给定事实和规则，它会自动分析其中的逻辑关系，然后允许用户通过查询，完成复杂的逻辑运算。

所谓“逻辑问题”，就是“苏格拉底是人，人都会死，所以苏格拉底会死”这一类的问题。

本文通过几个例子，简单介绍如何使用 Prolog 语言，主要参考了 xmonader 的[教程](https://xmonader.github.io/prolog/2018/12/21/solving-murder-prolog.html)。

## 一、SWI-Prolog

学习之前，请安装 Prolog 的运行环境 [SWI-Prolog](http://www.swi-prolog.org/)，可以边学边练。

SWI-Prolog 官网有各个操作系统的[二进制安装包](http://www.swi-prolog.org/download/stable)，下载安装即可。Debian / Ubuntu 系统可以用下面的命令。

```bash
$ sudo apt-get install swi-prolog
```

然后，启动即可。

```bash
$ swipl
?-
```

启动以后，就进入了 Prolog 运行环境，`?-`是命令提示符。

运行一下 Hello world。

```bash
?- write("Hello, world").
Hello, world!
true.
```

上面命令输出 Hello world。有几个地方需要注意，`write()`是输出命令，然后 Prolog 所有语句的结尾都用一个“点”（`.`）表示语句结束。这个命令本身是一个表达式，输出完成以后，会返回`true.`，也会显示出来。

`nl`是换行命令，如果想在 Hello world 之间插入一个换行，可以使用下面的语句。

```bash
?- write('Hello,'), nl, write('world').
Hello,
world
true.
```

如果要退出 SWI-Prolog，可以使用`halt`命令，别忘了后面还要加一个点。

```bash
?- halt.
```

## 二、基本语法

### 2.1 常量和变量

Prolog 的变量和常量规则很简单：小写字母开头的字符串，就是常量；大写字母开头的字符串，就是变量。

```bash
?- write(abc).
abc
true.

?- write(Abc).
_3386
true.
```

上面代码中，`abc`是常量，输出就是自身；`Abc`是变量，输出就是该变量的值。

### 2.2 关系

两个对象之间的关系，使用括号表示。比如，jack 的朋友是 peter，写成`friend(jack, peter).`。

注意，jack 的朋友是 peter，不等于 peter 的朋友是 jack。如果两个人都认为对方是朋友，要写成下面这样。

```bash
friend(jack, peter).
friend(peter, jack).
```

### 2.3 属性

如果括号里面只有一个参数，就表示某个对象拥有某个属性，比如 jack 是男性，写成`male(jack).`。括号里面是对象，括号外面是该对象的属性。

### 2.4 规则

规则是推理方法，即如何从一个论断得到另一个论断。

举例来说，我们定下一条规则：所有朋友关系都是相互的，即 peter 的朋友是 jack，取决于 jack 认为 peter 是朋友。规则写成下面这样。

```bash
friend(X, Y) :- friend(Y,X).
```

上面代码中，`X`和`Y`都是大写，表示这是两个变量。符号`:-`表示推理关系，可以读成“取决于”，`X`是`Y`的朋友，取决于`Y`是`X`的朋友。也就是说，只有`friend(Y,X)`为`true`，才能得到`friend(X, Y)`为`true`。

如果一条规则取决于多个条件，则条件之间使用逗号分隔。

```bash
mother(X, Y) :- child(Y,X), female(X).
```

上面代码中，`X`是`Y`的母亲，取决于两个条件。第一个条件是`Y`是`X`的小孩，第二个条件是`X`必须是女性。只有这个两个条件都为`true`，才能得到`mother(X, Y)`为`true`。

如果一个论断的成立，依赖于另一个论断的不成立，则使用`\+`表示规则。

```bash
onesidelove(X, Y) :- loves(X, Y), \+ loves(Y,X).
```

上面代码中，`X`单相思`Y`，取决于两个条件。第一个条件是`X`喜欢`Y`，第二个条件是`Y`不喜欢`X`。

### 2.5 查询

Prolog 支持查询已经设定的条件。

我们先写一个脚本`hello.pl`。

```bash
friend(john, julia).
friend(john, jack).
friend(julia, sam).
friend(julia, molly).
```

然后在 SWI-Prolog 里面加载这个脚本。

```bash
?- [hello].
true.
```

然后，可以查询两个人是否为朋友。

```bash
?- friend(john, jack).
true.

?- friend(john, sam).
false.
```

`listing()`函数可以列出所有的朋友关系。

```bash
?- listing(friend).
friend(john, julia).
friend(john, jack).
friend(julia, sam).
friend(julia, molly).

true.
```

还可以查询`john`有多少个朋友。

```bash
?- friend(john, Who).
Who = julia ;
Who = jack.
```

上面代码中，`Who`是变量名。任意的变量名都可以，只要首字母为大写。

## 三、地图着色问题

下面看看 Prolog 如何解决真实世界的问题。

![地图](https://ai.ia.agh.edu.pl/wiki/_media/pl:prolog:prolog_lab:map_coloring.png?cache=&w=640&h=400&tok=8ffff3)

我们知道，地图的相邻区域不能使用同一种颜色。现在有三种颜色：红、绿、蓝。如何为上面这幅地图着色？

首先，定义三种颜色。

```bash
color(red).
color(green).
color(blue).
```

然后，定义着色规则。

```bash
colorify(A,B,C,D,E) :-
    color(A), color(B), color(C), color(D), color(E),
    \+ A=B, \+ A=C, \+ A=D, \+ A=E,
    \+ B=C, \+ C=D, \+ D=E.
```

上面代码基本就是列举法。A 区域同时跟 BCDE 相邻，所以它们的颜色都不能一样。

将这两段代码封装成一个脚本`map.pl`。

```bash
?- [map].
true.
```

然后，执行函数`colorify()`，就会得到 ABCDE 可能的值。

```bash
?- colorify(A,B,C,D,E).
A = red,
B = D, D = green,
C = E, E = blue;
A = red,
B = D, D = blue,
C = E, E = green ;
A = green,
B = D, D = red,
C = E, E = blue ;
A = green,
B = D, D = blue,
C = E, E = red ;
A = blue,
B = D, D = red,
C = E, E = green ;
A = blue,
B = D, D = green,
C = E, E = red ;
```

可以看到，计算机给出了6组解，即有6种可行的着色方法。

## 四、谁是凶手

下面看一个比较有趣的逻辑题。

Boddy 先生死于谋杀，现有六个嫌疑犯，每个人在不同的房间，每间房间各有一件可能的凶器。根据下面的已知条件和线索，请你找出谁是凶手？

已知条件：六个嫌疑犯是三男（George、John、Robert）三女（Barbara、Christine、Yolanda）。

```bash
man(george). man(john). man(robert).
woman(barbara). woman(christine). woman(yolanda).
```

为了后面解题的方便，需要把“男人”和“女人”都定义为“人”。

```bash
person(X):- man(X).
person(X):- woman(X).
```

六个嫌疑犯分别待在六个房间：Bathroom、Dining Room、Kitchen、Living Room、 Pantry、Study。每间房价都有一件可疑的物品，可以当作凶器：Bag、Firearm、Gas、Knife、Poison、Rope。

```bash
location(bathroom). location(dining). location(kitchen).
location(livingroom). location(pantry). location(study).
weapon(bag). weapon(firearm). weapon(gas). 
weapon(knife). weapon(poison). weapon(rope).
```

下面声明一条规则，每个房间的人都是不一样的。

```bash
uniq_ppl(A,B,C,D,E,F):- 
  person(A), person(B), person(C), 
  person(D), person(E), person(F),  
  \+A=B, \+A=C, \+A=D, \+A=E, \+A=F, 
  \+B=C, \+B=D, \+B=E, \+B=F, 
  \+C=D, \+C=E, \+C=F, 
  \+D=E, \+D=F, 
  \+E=F.
```

凶手必须满足下面的条件。

```bash
murderer(X) :-
   uniq_ppl(Bathroom, Dining, Kitchen, Livingroom, Pantry, Study),
   uniq_ppl(Bag, Firearm, Gas, Knife, Poison, Rope),
```

注意，上面代码中`Bathroom`和`Bag`这样的字符串，都是大写字母开头，所以它们都是变量，代表对应的人。至于具体是谁，就是要推理得到的。

线索一：厨房里面是一个男人，那里的凶器不是绳索、刀子、包和火枪。

```bash
man(Kitchen), 
   \+Kitchen=Rope, \+Kitchen=Knife, \+Kitchen=Bag, \+Kitchen=Firearm,
```

线索二：Barbara 和 Yolanda 在浴室和书房。

```bash
woman(Bathroom), woman(Study), 
  \+christine=Bathroom, \+christine=Study, 
  \+barbara=Dining, \+barbara=Kitchen, 
  \+barbara=Livingroom, \+barbara=Pantry,
  \+yolanda=Dining, \+yolanda=Kitchen, 
  \+yolanda=Livingroom, \+yolanda=Pantry,
```
    
线索三：带包的那个人不是 Barbara 和 George，也不在浴室和饭厅。

```bash
\+barbara=Bag, \+george=Bag, 
\+Bag=Bathroom, \+Bag=Dining,
```

线索四：书房里面是一个带绳子的女人。

```bash
woman(Rope), Rope=Study,
```
    
线索五：起居室里面那件凶器，与 John 或 George 在一起。

```bash
man(Livingroom), \+Livingroom=robert,
```

线索六：刀子不在饭厅。

```bash
\+Knife=Dining,
```
    
线索七：书房和食品储藏室里面的凶器，没跟 Yolanda 在一起。

```bash
\+yolanda=Pantry, \+yolanda=Study,
```

线索八：George 所在的那间屋子里面，没有火枪。

```bash
Firearm=george,
```

线索九：Boddy 先生死在食品储藏室里，那里的凶器是煤气。

```bash
Pantry=Gas, Pantry=X, Gas=X,
```

上面代码中，变量`X`表示凶手。

完整的脚本`crime.pl`看[这里](https://github.com/xmonader/prolog-rands/blob/master/crime.pl)。

加载这个脚本，然后执行`murderer(X)`函数，过了大约10秒，就会显示凶手是谁。

```bash
?- [crime].
true.

?- murderer(X).
KILLER IS :christine
Bathroom: yolanda
Dining: george
Livingroom: john
Pantry: christine
Study: barbara
Kitchen: robert
Knife: yolanda
Gas: christine
Rope: barbara
Bag: john
Poison: robert
Firearm: george
X = christine ;
```

（完）
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTM5OTgwMDg5NSwxNzA5OTA5MDAwLDUyNT
QzNzI0MiwtODQ3NTExNjUsOTI0NjA1OTc4LC03ODY0ODkwMDIs
LTE0NjAwMzc1ODEsLTEzMDQ5ODQ5LDc3MTY3ODcyLC05NzQ2MT
c4MDksLTYxNzk3MTU0MiwxNTQ5NDM2NTIyLDIxMDQ0MTk3OTMs
MTUyOTczMTk0OCwtNjM3MTEwLC03MDQ1NTE1NzBdfQ==
-->