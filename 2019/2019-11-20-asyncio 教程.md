# Python 异步编程入门： asyncio 模块

这是一篇写给 JavaScript 程序员的 Python 教程。我发现 Python 的异步编程，其他人可能觉得很难，但是 JavaScript 程序员特别容易理解。

我真心建议，大家先学 JavaScript 的 [async/await](http://es6.ruanyifeng.com/#docs/async) 语法，再去学 Python 异步编程。两者的概念和语法类似，但是 JS 明显更简单，而且还有浏览器环境可以测试。

本文解释 asyncio 这个异步操作库的概念和基本用法，并且演示如何写一个 Python 脚本，来操作无头浏览器 pyppeteer 对网页截图。

## 一、Python 异步编程的由来

历史上，Python 并不支持异步编程，因为不需要。

它支持[多线程（`threading`模块）和多进程（`multiprocessing`模块）](https://timber.io/blog/multiprocessing-vs-multithreading-in-python-what-you-need-to-know/)，就没有必要一定支持异步了。万一一个线程（或进程）出现阻塞性操作，再新建其他线程（或进程）就可以了，程序不会卡死。

但是，多线程模型有“线程竞争”的问题，处理起来很复杂，还涉及到加锁。对一些简单的任务来说，增加了复杂性。如果 Python 要操作互联网，写起来就不是很便利。

为了解决这个问题，Python 3.4 引入了 `asyncio` 模块，可以说把 JavaScript 的异步解决方案`async/await`移植了过来，大大方便了异步任务的处理。这个功能得到了开发者的欢迎，API 几度升级，已经成为了从 Python 2 升级到 Python 3 的主要理由之一。

## 二、asyncio 的设计

asyncio 模块最大特点就是，代码运行在一个单线程（也是单进程）的环境，跟 JavaScript 一样。

由于只有一个线程，就不可能多个任务同时运行。asyncio 采用“多任务合作”模式（cooperative multitasking），允许异步任务暂时交出执行权给其他任务，等到其他任务完成后，再收回执行权继续往下执行，这跟 JavaScript 也是一样的。

由于代码的执行权在多个任务之间交换，所以看上去好像多个任务同时运行，其实底层只有一个线程，互相协作分配运行时间。

这看上去似乎是一个不合理的设计，Python 明明有多线程、多进程能力，为什么放着多余的 CPU 核心不用，而只用一个线程呢？但是另一方面，这种设计提高了单核 CPU 的运行效率，更重要的是，单线程环境简化了很多问题，使得代码可以很简单，符合直觉。

asyncio 模块会在单线程上，启动一个事件循环（event loop），监听有没有新进入循环的事件，加以处理，不断重复这个过程，直到异步任务执行结束。事件循环的内部机制，可以参考 [JavaScript 的模型](https://wangdoc.com/javascript/async/general.html#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF)，两者是一样的。

## 三、asyncio API

下面介绍 asyncio 模块几个最主要的 API。注意，执行环境必须是 Python 3.7 或更高。

第一步，加载 asyncio 这个模块。

```python
import asyncio
```

第二步，普通函数前面加上`async`关键字，就变成了 async 函数。这种函数最大特点是可以暂停，交出执行权。

```python
async def main():
```

第三步，在 async 函数内部的异步任务前面，加上`await`命令。

```python
await asyncio.sleep(1)
```

上面代码中，`asyncio.sleep(1)`方法可以生成一个异步任务，在事件循环中休眠1秒钟，然后结束。

执行引擎遇到`await`命令，就会在异步任务开始执行之后，暂停 当前 async 函数的执行，把执行权交给其他任务。等到异步任务结束，再把执行权交回 async 函数，继续往下执行。

第四步，`async.run()`方法加载 async 函数，启动事件循环。

```python
asyncio.run(main())
```

上面代码中，`asyncio.run()`在事件循环上监听 async 函数`main`的执行。等到执行完成后，事件循环才会终止。

## 四、async 函数的示例

下面看一个 async 函数的例子。新建一个脚本`async.py`，代码如下。

```python
#!/usr/bin/env python3
# async.py

import asyncio

async def count():
    print("One")
    await asyncio.sleep(1)
    print("Two")

async def main():
    await asyncio.gather(count(), count(), count())

asyncio.run(main())
```

上面脚本中，在 async 函数`main`的里面，`asyncio.gather()`方法将多个异步任务包装成一个新的异步任务，必须等到内部的异步任务都执行借宿，这个新的异步任务才会结束。

脚本的运行结果如下。

```bash
$ python3 async.py
One
One
One
Two
Two
Two
```

这种运行结果的原因是，三个`count()`依次执行，打印完`One`，就休眠1秒钟，把执行权交给下一个`count()`，所以先连续打印出三个`One`。

等到1秒钟休眠结束，执行权重新交回第一个`count()`，开始执行`await`命令后面的语句，所以会接着打印出三个`Two`。脚本总的运行时间是1秒。

作为对比，下面是同步脚本`sync.py`。

```python
#!/usr/bin/env python3
# sync.py

import time

def count():
    print("One")
    time.sleep(1)
    print("Two")

def main():
    for _ in range(3):
        count()

main()
```

这个脚本的执行结果如下。

```bash
$ python3 sync.py 
One
Two
One
Two
One
Two
```

上面运行结果的原因是，三个`count()`都是同步执行，必须等到前一个执行完，才能执行后一个。脚本总的运行时间是3秒。

## 五、实例：pyppeteer 模块

最后，演示一个异步编程实例：使用 async 函数操作网页。这个例子中，异步模式对代码的简化，体现得淋漓尽致。

这个例子需要用到 [pyppeteer 模块](https://pypi.org/project/pyppeteer/)，它是无头浏览器 Puppeteer 的 Python 移植，API 跟 JavaScript 版本基本一致。

首先，安装 pyppeteer。

```bash
$ python3 -m pip install pyppeteer
```

然后，写一个网页截图脚本`screenshot.py`。

```python
#!/usr/bin/env python3
# screenshot.py

import asyncio
from pyppeteer import launch

async def main():
    browser = await launch()
    page = await browser.newPage()
    await page.goto('http://example.com')
    await page.screenshot({'path': 'example.png'})
    await browser.close()

asyncio.run(main())
```

执行这个脚本，当前目录下就会生成网页截图`example.png`。

```bash
$ python3 screenshot.py
```

如果脚本执行时报错`No usable sandbox!`，可以参考[这里](https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md#setting-up-chrome-linux-sandbox)。另外，第一次执行这个脚本，会下载安装 Puppeteer，可能需要等待较长时间，但是以后执行就会很快。

Pyppeteer 的[官网](https://miyakogi.github.io/pyppeteer/)还给出了其他实例，比如向网页注入 JavaScript 代码，也可以参考。

## 六、参考链接

- [Async IO in Python: A Complete Walkthrough](https://realpython.com/async-io-python/), Brad Solomon

（完）

